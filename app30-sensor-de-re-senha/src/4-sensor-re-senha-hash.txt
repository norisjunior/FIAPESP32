// Sensor de ré com modo ADMIN
#include "EasyBuzzer.h"
#include "mbedtls/sha256.h"

#define trigPin 23
#define echoPin 22
#define pinLED 17
#define pinBuzzer 19

int16_t freqBeep = 800;
int minDistance = 40;
String comando = "";
int tentativas = 3;

// Hash da senha "1234" (hexadecimal com 64 caracteres)
const char* senha_hash_hex = "03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4";

// Função para converter bytes para string hexadecimal
String bytesToHex(const uint8_t* hash, size_t len) {
	String hex = "";
	const char hexChars[] = "0123456789abcdef";
	for (size_t i = 0; i < len; i++) {
	  hex += hexChars[(hash[i] >> 4) & 0x0F];
	  hex += hexChars[hash[i] & 0x0F];
	}
	return hex;
}

// Função para calcular SHA-256 de uma string
String sha256(String entrada) {
	uint8_t hash[32];  // SHA-256 = 256 bits = 32 bytes
	mbedtls_sha256_context ctx;

	mbedtls_sha256_init(&ctx);
	mbedtls_sha256_starts_ret(&ctx, 0); // 0 = SHA-256
	mbedtls_sha256_update_ret(&ctx, (const unsigned char*)entrada.c_str(), entrada.length());
	mbedtls_sha256_finish_ret(&ctx, hash);
	mbedtls_sha256_free(&ctx);

	return bytesToHex(hash, sizeof(hash));
}


void setup() {
  Serial.begin(115200);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(pinLED, OUTPUT);
  EasyBuzzer.setPin(pinBuzzer);

  Serial.println("=== Sensor de Ré ===");
  Serial.println("Digite 'ADMIN' para alterar configurações ou aguarde medições.");
}

void loop() {
  // --- Leitura de comandos pelo Serial ---
  while (Serial.available() > 0) {
    char c = Serial.read();
    Serial.print(c);  // mostra caractere digitado

    if (c == '\n' || c == '\r') {
      comando.trim();

      if (comando == "ADMIN") {
        Serial.println("\nDigite a senha (timeout de 1,5 segundo): ");
        Serial.setTimeout(1500); // espera até 1,5 segundo pela senha
        String pass = Serial.readStringUntil('\n');
        pass.trim();

  	    String hashDigitado = sha256(pass);
	      Serial.print("Hash da senha digitada: ");
        Serial.println(hashDigitado);

        if (tentativas == 1) { //Era a última tentativa
          Serial.println("Tentativas de senha máximas atingidas. Sistema bloqueado!");
          while(1); // trava até reiniciar
        }

        if (!hashDigitado.equalsIgnoreCase(senha_hash_hex)) {
          comando = "";
          tentativas--;
          Serial.print("Senha incorreta. Acesso negado. Tentativas restantes: "); Serial.println(tentativas);
          Serial.println("Digite 'ADMIN' para alterar configurações ou aguarde medições.");
          return;
        }

        tentativas = 3;
        // Senha correta: entra em modo manutenção
        digitalWrite(pinLED, HIGH);
        Serial.println("Acesso liberado! LED aceso.");
        Serial.print("Distância mínima atual: ");
        Serial.print(minDistance);
        Serial.println(" cm");
        Serial.println("Digite a nova distância mínima (cm) - (timeout de 1,5 segundo): ");

        // Espera nova distância
        while (true) {
          if (Serial.available()) {
            String entrada = Serial.readStringUntil('\n');
            entrada.trim();
            int novaDist = entrada.toInt();

            if (novaDist > 0) {
              minDistance = novaDist;
              Serial.print("Nova distância mínima definida: ");
              Serial.print(minDistance);
              Serial.println(" cm");
              digitalWrite(pinLED, LOW);
              Serial.println("Modo manutenção encerrado.\n");
              break;
            } else {
              Serial.println("Valor inválido. Digite novamente:");
            }
          }
          delay(50);
        }
      }

      comando = "";
    } else {
      comando += c;
    }
  }

  // --- Medição normal de distância ---
  long duration;
  int distance;

  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  duration = pulseIn(echoPin, HIGH);
  distance = duration * 0.034 / 2;

  Serial.print("Distância: ");
  Serial.print(distance);
  Serial.println(" cm");

  // --- Lógica do buzzer ---
  if (distance >= 100) {
    EasyBuzzer.beep(freqBeep);
    delay(300);
    EasyBuzzer.beep(0);
    delay(300);
  }
  else if (distance >= 50 && distance < 100) {
    EasyBuzzer.beep(freqBeep);
    delay(150);
    EasyBuzzer.beep(0);
    delay(150);
  }
  else if (distance >= minDistance && distance < 50) {
    EasyBuzzer.beep(freqBeep);
    delay(100);
    EasyBuzzer.beep(0);
    delay(100);
  }
  else {
    EasyBuzzer.beep(freqBeep);
    delay(10);
    EasyBuzzer.beep(0);
    delay(10);
  }

  EasyBuzzer.update();
}
