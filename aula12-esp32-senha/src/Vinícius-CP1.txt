#include <DHT.h>
#include <ESP32Servo.h>
#include "mbedtls/sha256.h"

// -------------------- PINOS --------------------
#define PIN_DHT   23
#define DHTMODEL  DHT22
#define PIN_SERVO 18
#define LED_R 25
#define LED_B 26
#define LED_G 27

// -------------------- OBJETOS ------------------
DHT dht(PIN_DHT, DHTMODEL);
Servo doorServo;

// -------------------- PARÂMETROS ------------------
float TEMP_MIN = 2.0; // Temperatura mínima de laboratório
float TEMP_MAX = 8.0; // Temperatura máxima de laboratório
float HUM_MAX  = 40.0;

int SERVO_LOCK_POS   = 0;    // 0° trancado
int SERVO_UNLOCK_POS = 90;   // 90° destrancado
uint32_t UNLOCK_MS   = 5000; // 5s aberto

// -------------------- SENHA (SHA-256) ------------------
// Hash SHA-256 da senha "1234"
const char* SENHA_HASH_HEX =
  "03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4";

// -------------------- ESTADO ------------------
String comando = "";
bool adminMode = false;
int tentativas = 0;
bool bloqueado = false;
unsigned long unblockAt = 0;

// -------------------- UTILS ------------------
String toHex(const uint8_t* data, size_t len) {
  static const char* hex = "0123456789abcdef";
  String out; out.reserve(len*2);
  for (size_t i=0;i<len;i++) {
    out += hex[(data[i]>>4) & 0xF];
    out += hex[data[i] & 0xF];
  }
  return out;
}

bool sha256Equals(const String& input, const char* hashHex) {
  uint8_t hash[32];
  mbedtls_sha256_context ctx;
  mbedtls_sha256_init(&ctx);
  mbedtls_sha256_starts_ret(&ctx, 0);
  mbedtls_sha256_update_ret(&ctx, (const unsigned char*)input.c_str(), input.length());
  mbedtls_sha256_finish_ret(&ctx, hash);
  mbedtls_sha256_free(&ctx);
  String hex = toHex(hash, 32);
  return hex.equalsIgnoreCase(hashHex);
}

void setLED(bool r, bool g, bool b) {
  digitalWrite(LED_R, r ? HIGH : LOW);
  digitalWrite(LED_G, g ? HIGH : LOW);
  digitalWrite(LED_B, b ? HIGH : LOW);
}

bool ambienteOK(float t, float h) {
  return (t >= TEMP_MIN && t <= TEMP_MAX && h <= HUM_MAX);
}

void abrirTrava() {
  doorServo.attach(PIN_SERVO);
  doorServo.write(SERVO_UNLOCK_POS);
  setLED(false, true, true);  // ciano = aberto
  Serial.println("[ACESSO LIBERADO] Trava aberta.");
  delay(UNLOCK_MS);
  doorServo.write(SERVO_LOCK_POS);
  delay(400);
  doorServo.detach();
  setLED(false, false, false);
  Serial.println("[TRAVA FECHADA] Acesso finalizado.");
}

// -------------------- SETUP ------------------
void setup() {
  Serial.begin(115200);
  delay(300);

  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(LED_B, OUTPUT);
  setLED(false, false, false);

  dht.begin();

  // Servo em posição inicial (trancado)
  doorServo.attach(PIN_SERVO);
  doorServo.write(SERVO_LOCK_POS);
  delay(400);
  doorServo.detach();


  Serial.println("Digite ADMIN para entrar no modo de autenticação.");
}

// -------------------- LOOP ------------------
void loop() {
  if (bloqueado && millis() > unblockAt) {
    bloqueado = false;
    tentativas = 0;
    Serial.println("[INFO] Bloqueio removido. Pode tentar novamente.");
  }

  while (Serial.available() > 0) {
    char c = Serial.read();

    // Tratar tanto '\n' quanto '\r' como "ENTER"
    if (c == '\n' || c == '\r') {
      // Ignora ENTERs repetidos sem conteúdo
      if (comando.length() == 0) continue;

      String cmd = comando;
      comando = "";
      cmd.trim();

      String upper = cmd;
      upper.toUpperCase();

      if (upper == "STATUS") {
        float h = dht.readHumidity();
        float t = dht.readTemperature();
        if (isnan(h) || isnan(t)) {
          Serial.println("[ERRO] Falha ao ler DHT.");
          setLED(true, false, false);
          delay(300);
          setLED(false, false, false);
        } else {
          Serial.printf("T=%.1f C | H=%.1f %%\n", t, h);
          Serial.printf("Limites: T[%.1f..%.1f] H<=%.1f\n", TEMP_MIN, TEMP_MAX, HUM_MAX);
        }
      }
      else if (upper.startsWith("THRESH")) {
        float tmin, tmax, humax;
        int matched = sscanf(upper.c_str(), "THRESH %f %f %f", &tmin, &tmax, &humax);
        if (matched == 3) {
          TEMP_MIN = tmin; TEMP_MAX = tmax; HUM_MAX = humax;
          Serial.printf("[OK] Limites ajustados: T[%.1f..%.1f] H<=%.1f\n", TEMP_MIN, TEMP_MAX, HUM_MAX);
          setLED(false, true, false); delay(250); setLED(false, false, false);
        } else {
          Serial.println("Uso: THRESH <tmin> <tmax> <humax>");
        }
      }
      else if (upper == "ADMIN") {
        if (bloqueado) {
          Serial.println("[BLOQUEADO] Aguarde o desbloqueio automático.");
        } else {
          adminMode = true;
          Serial.println("Modo ADMIN: Digite a senha e pressione ENTER:");
          setLED(false, false, true);
        }
      }
      else if (adminMode) {
        // cmd é a senha digitada (case-sensitive)
        if (sha256Equals(cmd, SENHA_HASH_HEX)) {
          Serial.println("[OK] Senha correta.");
          tentativas = 0;
          adminMode = false;

          float h = dht.readHumidity();
          float t = dht.readTemperature();
          if (isnan(h) || isnan(t)) {
            Serial.println("[ERRO] Falha ao ler DHT. Acesso negado.");
            setLED(true, false, false);
            delay(400);
            setLED(false, false, false);
          } else {
            Serial.printf("Condições atuais: T=%.1f C | H=%.1f %%\n", t, h);
            if (ambienteOK(t, h)) {
              setLED(false, true, false); // verde = ok
              abrirTrava();
            } else {
              Serial.println("[ACESSO NEGADO] Ambiente fora de faixa.");
              for (int i=0;i<2;i++) { setLED(true, false, false); delay(200); setLED(false, false, false); delay(150); }
            }
          }
        } else {
          tentativas++;
          Serial.printf("[X] Senha incorreta. Tentativa %d/3\n", tentativas);
          setLED(true, false, false); delay(250); setLED(false, false, false);
          if (tentativas >= 3) {
            bloqueado = true;
            unblockAt = millis() + 30000; // 30s
            adminMode = false;
            Serial.println("[BLOQUEIO] Muitas tentativas. Aguarde 30s.");
          }
        }
      }
      else {
        Serial.println("Comando inválido. Use: ADMIN | STATUS | THRESH");
      }
    } else {
      // Acumula caracteres (inclusive espaços)
      comando += c;
    }
  }
}

